\documentclass{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{times}
%\usepackage{psfrag,psfig,epsfig,epsf}
\usepackage{graphics}
\usepackage{multirow}
\usepackage{fullpage}
\usepackage{verbatim}
\usepackage{fancyheadings}
\usepackage[T1]{fontenc}
\usepackage{arev}
\usepackage{subfigure}
\usepackage{url}
\usepackage[noline,noend,ruled,linesnumbered]{algorithm2e}
\usepackage{algpseudocode}
\linespread{1.02} 

\pagestyle{empty}

\addtolength{\topmargin}{-20pt}
\addtolength{\oddsidemargin}{-5pt}
\addtolength{\textwidth}{20pt}
\addtolength{\textheight}{50pt}

\newenvironment{myitem}{\begin{list}{$\bullet$}
{\setlength{\itemsep}{-0pt}
\setlength{\topsep}{0pt}
\setlength{\labelwidth}{0pt}
%\setlength{\labelsep}{0pt}
\setlength{\leftmargin}{10pt}
\setlength{\parsep}{-0pt}
\setlength{\itemsep}{0pt}
\setlength{\partopsep}{0pt}}}%
{\end{list}}

\begin{document}

\sloppy

\noindent Group members: Matt Demusz, Frank Porco, Joyce Wang

\vspace{0.1in}

\begin{center}
due 02/18/14
\end{center}

\vspace{0.1in}

\noindent \underline{CS 344: DESIGN AND ANALYSIS OF COMPUTER
  ALGORITHMS \hspace{1.6in} SPRING 2014}

\vspace{0.1in}

\begin{center}
{\bf {\large Homework 1}}\\
Asymptotics and Number Theoretic Algorithms\\
\end{center}

\vspace{0.1in}

{\bf }

\begin{center}
{\bf Part A (20 points)}
\end{center}

\noindent {\bf Problem 1:} In each of the following situations
indicate whether $f=O(g)$ or $f=\Omega(g)$ or $f=\Theta(g)$:

\begin{enumerate}
\item $f(n) = \sqrt{2^{7n}},\ g(n) = \lg({7^{2n}})$

$f(n) = \sqrt{2^{7n}} = 2^{7n/2}$ and $g(n)$ = $2n lg(7)$. $f(n)$ is an exponential function, and $g(n)$ is a linear function. Because an exponential grows faster than a linear function, $f(n)$ = $\Omega(g)$. 

\item $f(n) = 2^{nln(n)},\ g(n) = n!$

Since $g(n) = n!$, we can use Stirling's approximation: $ln(n!) = n ln(n) - n + O(ln n)$. To get it in the same form as Stirling's we take $ln$ of $f(n)$ and $ln$ of $g(n)$
Stirling's approximation states that $ln(n!) = n ln(n) - n + O(ln n)$. Taking
the natural logarithm of $f(n)$, we have
\begin{eqnarray*}
    ln(f(n)) &=& ln(2^{n ln(n)}) \\
             &=& ln(2) n ln(n) \\
             &=& O(n log n)
\end{eqnarray*}

Thus, $f(n) = \Theta(g(n))$.

\item $f(n) = lg(lg^*n),\  g(n) = lg^*(lgn)$



\item $f(n) = \frac{lgn^2}{n},\ g(n) = lg^*n$
\item $f(n) = 2^n,\ g(n) = n^{lgn}$
\item $f(n) = 2^{\sqrt{lgn}},\ g(n) = n(lgn)^3$
\item $f(n) = e^{cos(n)},\ g(n) = lgn$
\item $f(n) = lgn^2,\ g(n) = (lgn)^2$
\item $f(n) = \sqrt{4n^2 - 12n + 9},\ g(n) = n^{\frac{3}{2}}$
\item $f(n) = \sum_{k=1}^{n} k, g(n) = (n+2)^2$
\end{enumerate}

{\emph Note:} The $lg^*n$ function is the number of times the
logarithm function must be iteratively applied before the result is
less than or equal to 1, i.e., $lg^*n = 0$ if $n \leq 1$ and $lg^*n =
1 + lg^(lgn)$ if $n > 1$. For instance, $lg^*4=2$, $lg^*16=3$,
$lg^*65536=4$, etc.


\begin{algorithm}[h]
\caption{${\tt Number\_Theoretic\_Algorithm}$ $($ integer $n$ ) }
\label{algo}
$N \leftarrow Random\_Sample( 0, 2^n-1)$\;
\If{ $N$ is even }
{
  $N \leftarrow N + 1$\;
}
$m \leftarrow N \mod\ n$\;
\For{ $j \leftarrow 0$ to $m$ }
{
  \If{ ${\tt Greatest\_Common\_Divisor}$( $j, N ) \neq 1$ }
  {
    return {\tt FALSE};
  }
  Compute $x,z$ so that $N - 1 = 2^z \cdot x$ and $x$ is odd\;
  $y_0 \leftarrow (N-1-j)^x \mod N$\;
  \For{ $i \leftarrow 1$ to $m$}
  {
    $y_i \leftarrow y_{i-1}^2 \mod N$\;
    $y_i \leftarrow y_i + y_{i-1} \mod N$\;
  }
  \If{ {\tt Low\_Error\_Primality\_Test}($y_m$) == {\tt FALSE} }
  {
    return {\tt FALSE}\;
  }
}
return {\tt TRUE}\;
\end{algorithm}

\noindent {\bf Problem 2:} Compute the asymptotic running time of the
above algorithm as a function of its input parameter, given:

\begin{myitem}
\item The running times of integer arithmetic operations (e.g.,
  multiplication of two large $n$-bit numbers is $O(n^2)$).
\item Assume that sampling a number $N$ is an operation linear to the
  number of bits needed to represent this number.
\end{myitem}

\noindent Do not just present the final result. For each line of
pseudo-code indicate the best running time for the corresponding
operation given current knowledge from lectures and recitations and
then show how the overall running time emerges.\\

1. $O(n)$: from notes\\
\indent 2. $O(1)$: check the last bit\\
\indent 3. $O(n)$: worst case for addition is having to flip 1s through the entire number\\
\indent 4. $O(n^2)$\\
\indent 5. $O(n)$: for loop runs linearly; everything inside gets multiplied by n\\
\indent 6. $O(n^3)$: Euclid's algorithm from notes\\
\indent 7. $O(1)$: returning a boolean doesn't depend on input size\\
\indent 8. $O(n)$\\
\indent 9. $O(n^2)$: problem specifies multiplication (the "power x") as $O(n^2)$; number in front is dropped\\
\indent 10. $O(n)$\\
\indent 11. $O(n^2)$: problem specifies multiplication (the "power 2") as $O(n^2)$\\
\indent 12. $O(n)$:a mod b\\
\indent 13. $O(n log^3n)$: primality test\\
\indent 14. $O(1)$: returning a boolean doesn't depend on input size\\
\indent 15. $O(1)$: returning a boolean doesn't depend on input size\\

\begin{center}
{\bf Part B (30 points)}
\end{center}

\noindent {\bf Problem 3:} 
\begin{myitem}
\item Consider that we have a tree data structure $T_m^N$, where every
  node can have at most $m$ children and the tree has at most $N$
  nodes total. Compute a lower bound for the height of the tree.\\

\item Consider two such trees $T_m^N$ and $T_{m'}^N$ that are
  ``perfect'', i.e., every node has exactly $m$ and $m'$ children
  correspondingly. Now, consider the functions $h_m(N)$ and
  $h_{m'}(N)$ that express the heights of these perfect trees for
  different values of $N$. What is the asymptotic behavior of $h_m$
  relative to $h_{m'}$ and under what conditions?\\

\item Consider the following rule for modular exponentiation, where
  $x$ is in the order of $2^m$ and $y$ is in the order of $2^n$. What
  is the running time of computing the result according to this rule?
$$x^y = \left\{
\begin{array}{c l}     
    (x ^{\lfloor \frac{y}{2} \rfloor} )^2,  & \textrm{ if y is even }\\
    x \cdot (x^{\lfloor \frac{y}{2} \rfloor} )^2, & \textrm{ if y is odd}
\end{array}\right.$$
\end{myitem}

\noindent {\bf Problem 4:}
\begin{myitem}
\item Compute the following: $2^{902}$ mod 7.\\
\item Find the modulo multiplicative inverse of 11 mod 120, 13 mod 45,
  35 mod 77, 9 mod 11, 11 mod 1111.\\
\item Assume that for a number $x$ the following property is true:
  $\forall\ y \in [1,x-1]:\ gcd(x,y) = 1$. Compute the running time of
  an efficient algorithm for finding all the inverses modulo $x^m$
  from the set $\{0, 1, \ldots, x^m-1\}$ that exist.\\
\end{myitem}

\noindent {\bf Problem 5:} 
\begin{myitem}
\item Assume two positive integers x < y. Then the pairs
  $(5x+3y,3x+2y)$ and $(x,y)$ have the same greater common
  divisor. True or False, explain.\\

\item Consider the following sequence of numbers: $s_n = 1 +
  \Pi_{i=0}^{n-1} s_i$, where $s_0 = 2$. Prove that any two numbers in
  this sequence are relatively prime.\\
\end{myitem}

\begin{center}
{\bf Part C (30 points)}
\end{center}

\noindent {\bf Problem 6:} Our goal is to assign $(2^{31}-1)$ integers
into 256 slots $\{0,1, \dots, 255\}$ and achieving the properties of
universal hashing. Notice that 256 is not a prime number. Assume the
following approach towards this objective.\\

\noindent Consider a 32-bit integer $y$ and the following set $\mathcal{M}$ of
hash functions, so that:
\begin{myitem}
\item each $m \in \mathcal{M}$ corresponds to a unique $8 \times 32$
  matrix $M$ having elements only 0 or 1.
\item and $m(y) = M \cdot y$ mod $2$, i.e., multiply the matrix with
  the 32-bit vector corresponding to number $y$ and then apply the
  modulo operation on each bit of the resulting vector.\\
\end{myitem}

\noindent Such functions map a 32-bit vector into an 8-bit vector,
which can then be interpreted as an 8-bit number that indicates the
original number's slot in the range $0 \sim 255$. Notice that there
are $2^{8\times32}=2^{256}$ different $\{0,1\}$ matrices in the set
$\mathcal{H}$.\\

\noindent Provide the following:
\begin{myitem}
\item A proof that the hash function family $\mathcal{M}$ is
  universal.

\item A comparison to the universal hash function family described in
  DPV chapter 1.5.2. How many random bits are needed here?\\
\end{myitem}

\newpage

\noindent {\bf Problem 7:} Answer the following sequence of problems:
\begin{itemize}

\item Assume that number $n$ is prime, then all numbers $1 \leq x < n$
  are invertible modulo $n$. Which of these numbers are their own
  inverse module $n$?\\

For a number (x) to be its own inverse, the following must be true:
$$x^{2} \equiv 1 \pmod{n}$$
So $x^{2} \equiv 1 \pmod{n}$ --> $x^{2}-1 \equiv 0 \pmod{n}$
--> $(x-1)(x+1) \equiv 0 \pmod{n}$\\
Since n is prime, we must have either $(x-1) \equiv 0 \pmod{n}$
or $(x+1) \equiv 0 \pmod{n}$. So the only numbers that will satisfy 
these two equations for x are 1 ($((1)-1) \equiv 0 \pmod{n}$ and 
n-1 ($((n-1)+1) \equiv 0 \pmod{n}$. This means that the only numbers
that are greater than or equal to 1 and less than n that are their own
inverse are 1 and n-1.

\item Show that $(n-1)! \equiv -1 \mod n$) for prime $n$. [Hint:
  Compute the value of $(n-1) \mod n$ by considering how it arises by
  pairing two numbers smaller than $n$ that are multiplicative
  inverses modulo $n$.]\\

Since n is prime, each number $a = {1, ... , n-1}$ has an inverse $\pmod{n}$. 
We can pair up the numbers in between 2 and n-2 so that a number in the pair
is the modular inverse of the other. 1 and n-1 are their own modular inverse, as proven above.
Multiplying these pairs, 1 , and n-1 is the same as (n-1)!. Since each of these pairs
are a number grouped with their modular inverse, they each only contribute a value of 1,
since for each pair:
$$pair \equiv 1 \pmod{n}$$
So that leaves the 1 and the n-1, meaning that:
$$(n-1)! \equiv 1 * (n-1) \equiv (n-1) \equiv -1 \pmod{n} \hspace{.2in}=> \hspace{.2in} n \equiv 0 \pmod{n}$$
Showing that the original equation is true for a prime n.


\item Show that if $n$ is not prime, then $(n-1)! \neq -1 \mod
  n$. [Hint: What does it mean that $n$ is not prime in terms of the
    numbers $1 \leq x < n$?]\\

Since n is not a prime number, it has a divisor (a) such that 1 < a < n.
So a must be one of the numbers that makes up (n-1)!. This tells us that
a divides (n-1)! Looking at the origanal equation, $(n-1)! = -1 \pmod{n}$
--> $(n-1)!+1 = 0 \pmod{n}$. This tells us that n divides\\((n-1)! + 1), and since
a is a divisor of n, a must also divide ((n-1)! + 1). But if that were the case, then
that would mean that a divides both (n-1)! and ((n-1)! + 1). This would mean a would 
have to equal 1, which contradicts 1 < a < n.\\Therefore, if n is not prime, then
$(n-1)! \neq -1 \pmod{n}$.

\item The above process can be used as a primality test instead of
  Fermat's Little theorem as it is an if-and-only-if condition for
  primality. Why can't we immediately base a primality test on this
  rule? [Tip: Even if you are not able to answer the previous two
    questions, you should be able to argue about this question.]\\


\end{itemize}

\begin{center}
{\bf Part D (30 points)}
\end{center}


\noindent {\bf Problem 8:}

\noindent A. Make a table with three columns. The first column is all numbers
from 0 to 36. The second is the residues of these numbers modulo 5;
the third column is the residues modulo 7.\\

\begin {tabular}{l || c | r}
\# & \%5 & \%7 \\ \hline
0 & 0 & 0 \\ \hline
1 & 1 & 1 \\ \hline
2 & 2 & 2 \\ \hline
3 & 3 & 3 \\ \hline
4 & 4 & 4 \\ \hline
5 & 0 & 5 \\ \hline
6 & 1 & 6 \\ \hline
7 & 2 & 0 \\ \hline
8 & 3 & 1 \\ \hline
9 & 4 & 2 \\ \hline
10 & 0 & 3 \\ \hline
11 & 1 & 4 \\ \hline
12 & 2 & 5 \\ \hline
\end{tabular}
\hspace{0.2in}
\begin{tabular}{l || c | r}
\# & \%5 & \%7 \\ \hline
13 & 3 & 6 \\ \hline
14 & 4 & 0 \\ \hline
15 & 0 & 1 \\ \hline
16 & 1 & 2 \\ \hline
17 & 2 & 3 \\ \hline
18 & 3 & 4 \\ \hline
19 & 4 & 5 \\ \hline
20 & 0 & 6 \\ \hline
21 & 1 & 0 \\ \hline
22 & 2 & 1 \\ \hline
23 & 3 & 2 \\ \hline
34 & 4 & 3 \\ \hline
\\
\end{tabular}
\hspace{0.2in}
\begin{tabular}{l || c | r}
\# & \%5 & \%7 \\ \hline
35 & 0 & 4 \\ \hline
36 & 1 & 5 \\ \hline
37 & 2 & 6 \\ \hline
38 & 3 & 0 \\ \hline
39 & 4 & 1 \\ \hline
30 & 0 & 2 \\ \hline
31 & 1 & 3 \\ \hline
32 & 2 & 4 \\ \hline
33 & 3 & 5 \\ \hline
34 & 4 & 6 \\ \hline
35 & 0 & 0 \\ \hline
36 & 1 & 1 \\ \hline
\\
\end{tabular}

\noindent B. Consider two different prime numbers $x$ and $y$. Show that the
following is true: for every pair of numbers $m$ and $n$ so that: $0
\leq m < x$ and $0 \leq n < y$, there is a unique integer $q$, where
$0 \leq q < xy$, so that:
$$q \equiv m \pmod{x}$$
$$q \equiv n \pmod{y}$$

Suppose there exists $q_1, q_2$ and $q_1 != q_2$ such that $q_1 = (m, n)$ and $q_2 = (m, n)$\\

1. $q_1 = k_1x+m$, $q_2 = l_1x+m$\\
\indent 2. $q_1 = k_2y+n$, $q_2 = l_2y+n$\\
\indent 3. $q_1 - q_2 = (k_1x + m) - (l_1x + m) = (k_1 - l_1)$ from 1
\indent 4. $q_1 - q_2 = (k_2 - l_2) y$ from 2
\indent 5. $(k_1 - l_1)x = (k_2 - l_2)y$\\
\indent 6. $x=\dfrac{(k_2 - l_2)}{(k_1 - l_1)}y$\\
\indent 7. $\dfrac{(k_2 - l_2)}{(k_1 - l_1)} = 1$ because prime number x can't be the product of two numbers\\
\indent 8. $x = y$ contradicts hypothesis\\
\indent 9. x and y have to be equal\\
  
\noindent C. The previous problem asks to go from $q$ to $(m,n)$. It is also
possible to go the other way. In particular, show the following:

$$q = ( m \cdot y \cdot (y^{-1} \bmod{x}) + n \cdot x \cdot
(x^{-1} \bmod{y}) ) \bmod{xy}$$

[Hint: Ensure that if the above is true then the expressions in section B are
  also true. Consider the values of the following terms: $c_x = y
  \cdot (y^{-1} \bmod{x})$ and $c_y = x \cdot (x^{-1} \bmod{y})$ and
their values $\mod{x}$ and $\mod{y}$.]\\

\noindent D. What happens in the case of three primes $x$, $y$ and $z$? Do the
above properties still hold? If they do, how do they look like in this
case?\\



\noindent {\bf Problem 9:} There is an office, in which every member
uses RSA to conduct secure communication with others.  For example,
when Alice wants to send Bob a message, she will first use Bob's
public key to encrypt the message, then sends it to Bob, Bob then uses
his private key to decrypt the message.  In order to make things easy,
the office maintains a directory listing every member's public key,
everybody in the office has access to it. A public key looks like $(N,
e)$ (as defined in DPV-1.4.2).

\noindent One day, Alice sent a message (smaller than any $N$) to Bob,
Charlie, and David via the RSA based secure communication, but the
encrypted messages were intercepted by the webmaster Mallory. Mallory
used some network tricks and found out who the receivers were, then he
checked their public keys in the directory. This is what Mallory got:

\begin{center}
  \begin{tabular}{ | c | c | c | }
    \hline
    Receiver & Encrypted message & Public key \\ \hline
    Bob & 674 & (3337, 3) \\
    Charlie & 36 & (187, 3) \\
    David & 948 & (1219, 3) \\
    \hline
  \end{tabular}
\end{center}

\noindent Finally, Mallory recovered the original message. How did
Mallory do this? What is the original message?\\

\noindent {\bf How Malory did it:} Malory could have used a combination of
the chinese remainder theorem and Gauss's algorithm. Malory can use Gauss's
algorithm to find the message (x) using the enrypted messges ($c_1$,$c_2$,$c_3$),
and the N values ($n_1$,$n_2$,$n_3$) respectivley.

$$x \equiv c_1 \pmod{n_1}$$
$$x \equiv c_2 \pmod{n_2}$$
$$x \equiv c_3 \pmod{n_3}$$

\noindent From the chinese remainder theorem, we know that the above congruences
have a solution (x) which is unique modulo $n_1$,$n_2$,$n_3$. Now we can use Guass's
algorithm to solve for x.\\

\noindent $n_1 = 3337$ \hspace{1in} $c_1 = 674$\\
$n_2 = 187$ \hspace{1.1in} $c_2 = 36$ \hspace{1in} $e = 3$\\
$n_3 = 1219$ \hspace{1in} $c_3 = 948$\\
$N = n_1n_2n_3 = 3337*187*1219 = 760679161$\\
$N_1 = N/n_1 = 760679161/3337 = 227953$\\
$N_2 = N/n_2 = 760679161/187 = 4067803$\\
$N_3 = N/n_3 = 760679161/1219 = 624019$\\
$d_1 = N_1^{-1} \pmod{n_1} = 227953^{-1} \pmod{3337} = 251$\\
$d_2 = N_2^{-1} \pmod{n_2} = 4067803^{-1} \pmod{187} = 70$\\
$d_3 = N_3^{-1} \pmod{n_3} = 624019^{-1} \pmod{1219} = 671$\\
$x^{3} = c_1N_1d_1 + c_2N_2d_2 + c_3N_3d_3 \pmod {N}$\\
$x^{3} = ((674*227953*251)+(36*4067803*70)+(948*624019*671))\pmod{760679161}$\\
$x^{3} = 74088$\\
$x = 42$\\

\noindent Malory, knowing the encrypted messages and the respective public keys could have
applied Gauss's theorem like this and have come up with the original message (x), which was 42.

\end{document}

